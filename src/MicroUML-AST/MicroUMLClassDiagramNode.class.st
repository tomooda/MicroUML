Class {
	#name : 'MicroUMLClassDiagramNode',
	#superclass : 'MicroUMLAstNode',
	#instVars : [
		'classes',
		'associations',
		'announcer'
	],
	#category : 'MicroUML-AST',
	#package : 'MicroUML-AST'
}

{ #category : 'adding' }
MicroUMLClassDiagramNode >> addAssociation: aMicroUMLAssociationNode [

	(associations
		 at: aMicroUMLAssociationNode leftClass
		 ifAbsentPut: [ OrderedCollection new ]) add:
		aMicroUMLAssociationNode.
	^ aMicroUMLAssociationNode
]

{ #category : 'announcing' }
MicroUMLClassDiagramNode >> announceChange [

	self announcer announce:
		(MicroUMLClassDiagramChangedAnnouncement new
			 diagram: self;
			 yourself)
]

{ #category : 'announcing' }
MicroUMLClassDiagramNode >> announcer [

	^ announcer ifNil: [ announcer := Announcer new ]
]

{ #category : 'accessing' }
MicroUMLClassDiagramNode >> associations [

	^ Array streamContents: [ :stream |
		  self associationsDo: [ :association | stream nextPut: association ] ]
]

{ #category : 'accessing' }
MicroUMLClassDiagramNode >> associations: aCollectionOfMicroUMLAssociationNode [

	| newAssociations |
	newAssociations := OrderedDictionary new.
	aCollectionOfMicroUMLAssociationNode do: [ :associationNode |
			associationNode diagram: self.
			(newAssociations
				 at: associationNode leftClass
				 ifAbsentPut: [ OrderedCollection new ]) add: associationNode ].
	associations := newAssociations
]

{ #category : 'enumerating' }
MicroUMLClassDiagramNode >> associationsDo: aBlock [

	associations valuesDo: [ :assocs | assocs do: aBlock ]
]

{ #category : 'accessing' }
MicroUMLClassDiagramNode >> associationsForLeftClass: aSymbol [

	^ associations at: aSymbol ifPresent: #asArray ifAbsent: [ #(  ) ]
]

{ #category : 'class access' }
MicroUMLClassDiagramNode >> astBuilderClass [

	^ MicroUMLAstBuilder
]

{ #category : 'accessing' }
MicroUMLClassDiagramNode >> classAt: aSymbol [

	^ classes at: aSymbol
]

{ #category : 'class access' }
MicroUMLClassDiagramNode >> classNodeClass [

	^ MicroUMLClassNode
]

{ #category : 'accessing' }
MicroUMLClassDiagramNode >> classes [

	^ classes values asArray
]

{ #category : 'accessing' }
MicroUMLClassDiagramNode >> classes: aCollectionOfMicroUMLClassNode [

	classes := (aCollectionOfMicroUMLClassNode collect: [ :classNode |
			            classNode diagram: self.
			            classNode name -> classNode ]) asOrderedDictionary
]

{ #category : 'enumerating' }
MicroUMLClassDiagramNode >> classesDo: aBlock [

	classes valuesDo: aBlock
]

{ #category : 'accessing' }
MicroUMLClassDiagramNode >> ensureClassNamed: aSymbol [

	^ classes at: aSymbol ifAbsentPut: [
			  self classNodeClass new
				  name: aSymbol;
				  diagram: self;
				  yourself ]
]

{ #category : 'accessing' }
MicroUMLClassDiagramNode >> hasClassNamed: aStringOrSymbol [

	^ classes includesKey: aStringOrSymbol asSymbol
]

{ #category : 'initialization' }
MicroUMLClassDiagramNode >> initialize [

	super initialize.
	classes := OrderedDictionary new.
	associations := OrderedDictionary new
]

{ #category : 'printing' }
MicroUMLClassDiagramNode >> microUMLSource [

	^ String streamContents: [ :stream | self printMicroUMLOn: stream ]
]

{ #category : 'printing' }
MicroUMLClassDiagramNode >> printMicroUMLOn: aStream [

	self printMicroUMLOn: aStream associationsUnderClasses: true
]

{ #category : 'printing' }
MicroUMLClassDiagramNode >> printMicroUMLOn: aStream associationsUnderClasses: aBoolean [

	aBoolean = true
		ifTrue: [ self printMicroUMLWithAssociationsUnderClassesOn: aStream ]
		ifFalse: [
		self printMicroUMLWithAssociationsOutsideClassesOn: aStream ]
]

{ #category : 'printing' }
MicroUMLClassDiagramNode >> printMicroUMLWithAssociationsOutsideClassesOn: aStream [

	aStream nextPutAll: self astBuilderClass name.
	self classesDo: [ :classNode |
			classNode isEmptyDefinition ifFalse: [
					aStream
						cr;
						nextPutAll: '===';
						cr.
					classNode printMicroUMLOn: aStream ] ].
	self associationsDo: [ :associationNode |
			aStream
				cr;
				nextPutAll: '===';
				cr.
			associationNode printMicroUMLOn: aStream ]
]

{ #category : 'printing' }
MicroUMLClassDiagramNode >> printMicroUMLWithAssociationsUnderClassesOn: aStream [

	aStream nextPutAll: self astBuilderClass name.
	self classesDo: [ :classNode |
			aStream
				cr;
				nextPutAll: '===';
				cr.
			classNode printMicroUMLOn: aStream.
			(self associationsForLeftClass: classNode name) ifNotEmpty: [
					:assocs |
					(classNode isEmptyDefinition and: [ assocs size = 1 ])
						ifTrue: [
								aStream space.
								assocs first printMicroUMLInLeftClassOn: aStream ]
						ifFalse: [
								assocs do: [ :associationNode |
										aStream
											cr;
											nextPutAll: '  '.
										associationNode printMicroUMLInLeftClassOn: aStream ] ] ] ]
]

{ #category : 'adding' }
MicroUMLClassDiagramNode >> removeAssociation: aMicroUMLAssociationNode [

	associations
		at: aMicroUMLAssociationNode leftClass
		ifPresent: [ :associationNodes |
				associationNodes
					remove: aMicroUMLAssociationNode ifAbsent: [ ];
					ifEmpty: [
						associations removeKey: aMicroUMLAssociationNode leftClass ] ].
	^ aMicroUMLAssociationNode
]

{ #category : 'accessing' }
MicroUMLClassDiagramNode >> renameClass: aSymbol to: anotherSymbol [

	(classes includesKey: aSymbol) ifTrue: [
			classes := (classes associations collect: [ :assoc |
					            (assoc key = aSymbol
						             ifTrue: [ anotherSymbol ]
						             ifFalse: [ assoc key ]) -> assoc value ])
				           asOrderedDictionary ].
	classes do: [ :classNode |
		classNode renameClass: aSymbol to: anotherSymbol ].
	(associations includesKey: aSymbol) ifTrue: [
			associations := (associations associations collect: [ :assoc |
					                 (assoc key = aSymbol
						                  ifTrue: [ anotherSymbol ]
						                  ifFalse: [ assoc key ]) -> assoc value ])
				                asOrderedDictionary ].
	associations do: [ :associationNodes |
			associationNodes do: [ :associationNode |
				associationNode renameClass: aSymbol to: anotherSymbol ] ]
]

{ #category : 'enumerating' }
MicroUMLClassDiagramNode >> symbolsDo: aBlock [

	classes do: [ :classNode | classNode symbolsDo: aBlock ].
	associations do: [ :associationNodes |
			associationNodes do: [ :associationNode |
				associationNode symbolsDo: aBlock ] ]
]
